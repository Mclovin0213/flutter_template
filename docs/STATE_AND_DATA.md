# Guide: State and Data Management

This document provides instructions and best practices for managing data models and application state in this template, using `Freezed` and `Riverpod`.

## Data Models with Freezed

We use the [Freezed](https://pub.dev/packages/freezed) package to create immutable data models. Immutability prevents accidental state changes and makes your data flow more predictable. Freezed also automatically generates methods for JSON serialization (`toJson`/`fromJson`), copying (`copyWith`), and equality checking.

### Creating a New Model

When you need a new data model (e.g., for a `Product`), follow these steps.

1.  **Create the file** inside your feature's `models` directory. For example: `lib/features/prouct/models/product.dart`.

2.  **Use the Freezed template**. Add the following content to your file, customizing it for your `Product` model.

    ```dart
    // lib/features/product/models/product.dart

    import 'package:freezed_annotation/freezed_annotation.dart';

    // These part files will be generated by build_runner.
    // The name must match your file name.
    part 'product.freezed.dart';
    part 'product.g.dart';

    @freezed
    class Product with _$Product {
      // This is your model's constructor.
      // Define the properties of your model here.
      const factory Product({
        required String id,
        required String name,
        required double price,
        String? description, // Optional property
      }) = _Product;

      // This factory constructor is required for JSON serialization.
      // It tells Freezed how to create a Product from a JSON map.
      factory Product.fromJson(Map<String, dynamic> json) =>
          _$ProductFromJson(json);
    }
    ```

3.  **Run the Code Generator**. After saving the file, you must run the `build_runner` to generate the `*.freezed.dart` and `*.g.dart` files. These files contain the actual implementation of your model.

    ```sh
    flutter pub run build_runner build --delete-conflicting-outputs
    ```

    > **You should never edit the `.freezed.dart` or `.g.dart` files manually.** They will be overwritten the next time you run the build command.

---

## State Management with Riverpod

We use [Riverpod](https://riverpod.dev/) with its generator (`riverpod_generator`) for state management. This provides a compile-safe, simple, and powerful way to manage state and inject dependencies.

### Creating a New Provider

Providers are the core of your application's logic. They can fetch data, perform business logic, and manage UI state.

1.  **Create the file** inside your feature's `providers` directory. For example: `lib/features/product/providers/product_provider.dart`.

2.  **Use the Riverpod Generator (`@riverpod`)**. Define a function and annotate it with `@riverpod`. The generator will create the provider for you.

    Here is an example of a provider that fetches a list of products from a repository.

    ```dart
    // lib/features/product/providers/product_provider.dart

    import 'package:riverpod_annotation/riverpod_annotation.dart';
    import 'package:flutter_template/features/product/models/product.dart';
    import 'package:flutter_template/features/product/repositories/product_repository.dart';

    // The part file will be generated by build_runner
    part 'product_provider.g.dart';

    // This annotation tells the generator to create a provider
    // called `allProductsProvider`.
    @riverpod
    Future<List<Product>> allProducts(AllProductsRef ref) {
      // You can use the 'ref' object to read other providers.
      // Here, we get an instance of our repository.
      final productRepository = ref.watch(productRepositoryProvider);

      // Fetch the data and return it.
      // Riverpod will automatically handle loading and error states.
      return productRepository.getProducts();
    }
    ```

3.  **Run the Code Generator**. Just like with Freezed, you must run `build_runner` after creating or changing a provider to generate the `*.g.dart` file.

    ```sh
    flutter pub run build_runner build --delete-conflicting-outputs
    ```

### Using the Provider in the UI

To use your new provider in a widget, make the widget extend `ConsumerWidget` and use the `ref.watch()` method.

```dart
class ProductListScreen extends ConsumerWidget {
  const ProductListScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Watch the provider. Riverpod will rebuild the widget
    // when the state changes (e.g., from loading to data).
    final allProductsAsync = ref.watch(allProductsProvider);

    return Scaffold(
      body: allProductsAsync.when(
        // Show a loading indicator while fetching
        loading: () => const Center(child: CircularProgressIndicator()),
        // Show an error message if something went wrong
        error: (err, stack) => Center(child: Text('Error: $err')),
        // Show the list of products when the data is available
        data: (products) => ListView.builder(
          itemCount: products.length,
          itemBuilder: (context, index) => ListTile(
            title: Text(products[index].name),
          ),
        ),
      ),
    );
  }
}
```
