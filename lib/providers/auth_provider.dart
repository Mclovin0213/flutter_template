// Dart imports
import 'dart:async';
import 'dart:io';

// Flutter external package imports
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart'; // Only for ImageProvider, if repository returns it
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

// App relative file imports
import '../models/user_profile.dart';
import '../repositories/user_profile_repository.dart'; // Make sure this path is correct

// These 'part' files will be generated by build_runner
part 'auth_provider.g.dart';

// AuthState enum, as provided in the refactored text example
enum AuthState { unknown, authenticated, unauthenticated }

@riverpod
class Auth extends _$Auth {
  @override
  Stream<User?> build() {
    // This stream directly reflects Firebase Auth state changes.
    // Riverpod automatically handles the subscription and exposes the state as AsyncValue<User?>.
    // We now use `firebaseAuth` as per your repository's internal FirebaseAuth instance.
    return ref
        .watch(userProfileRepositoryProvider)
        .firebaseAuth
        .authStateChanges();
  }

  // --- Authentication Actions ---

  /// Attempts to sign in the user with the given email and password.
  /// Throws an [Exception] with a user-friendly message on failure.
  Future<void> signInWithPassword(String email, String password) async {
    try {
      // Use `firebaseAuth` from the repository instance.
      await ref
          .read(userProfileRepositoryProvider)
          .firebaseAuth
          .signInWithEmailAndPassword(email: email, password: password)
          .timeout(
            const Duration(seconds: 10),
          ); // Added timeout from original logic
    } on FirebaseAuthException catch (e) {
      String errorMessage;
      if (e.code == "wrong-password" ||
          e.code == "user-not-found" ||
          e.code == "invalid-email" ||
          e.code == "INVALID_LOGIN_CREDENTIALS" ||
          e.code == "invalid-credential") {
        errorMessage =
            "Email/Password is incorrect - please check your credentials and try again.";
      } else if (e.code == "too-many-requests") {
        errorMessage =
            "Too many failed login attempts - please try again later.";
      } else if (e.code == "timeout") {
        errorMessage =
            "Login attempt took too long - please check internet connection and try again.";
      } else if (e.code == "network-request-failed") {
        errorMessage =
            "A network error occurred - please check internet connection and try again.";
      } else {
        errorMessage =
            "An unknown error occurred during authentication. Please try again.";
      }
      throw Exception(
        errorMessage,
      ); // Re-throw as a generic Exception for UI consumption
    } on TimeoutException {
      throw Exception(
        "Login attempt took too long - please check internet connection and try again.",
      );
    } catch (e) {
      throw Exception("An unexpected error occurred during sign-in: $e");
    }
  }

  /// Signs out the current user.
  /// Also clears Firebase Firestore persistence for a clean state.
  Future<void> signOut() async {
    // Use `firebaseAuth` from the repository instance.
    await ref.read(userProfileRepositoryProvider).firebaseAuth.signOut();
    // Clear Firebase Firestore persistence for a clean logout state.
    // This is a global operation, hence directly calling FirebaseFirestore.
    await FirebaseFirestore.instance.terminate();
    await FirebaseFirestore.instance.clearPersistence();
    // Riverpod will automatically dispose and rebuild dependent providers (like userProfileProvider)
    // when the Auth state changes to unauthenticated.
  }

  /// Updates the current user's password.
  /// Throws an [Exception] on failure.
  Future<void> updatePassword(String newPassword, {String? curPassword}) async {
    final userProfileRepo = ref.read(userProfileRepositoryProvider);
    final user = userProfileRepo
        .firebaseAuth
        .currentUser; // Use `firebaseAuth` from the repository
    if (user == null) {
      throw Exception("No authenticated user to update password.");
    }

    // Perform basic password validation locally
    String validationError = _validatePassword(newPassword);
    if (validationError.isNotEmpty) {
      throw Exception(validationError);
    }

    try {
      // Re-authenticate if an old password is provided (Firebase requires this for security)
      if (curPassword != null) {
        final authCredential = EmailAuthProvider.credential(
          email: user.email!,
          password: curPassword,
        );
        await user.reauthenticateWithCredential(authCredential);
      }

      await user.updatePassword(newPassword);

      // If password update is successful, update the `dateLastPasswordChange` in the UserProfile.
      // We read the current profile, create a copy with the updated date, and write it back.
      final currentProfile = await ref.read(
        userProfileProvider.future,
      ); // Get current profile state
      if (currentProfile != null) {
        final updatedProfile = currentProfile.copyWith(
          // Use DateTime.now() to mark the change, or subtract a few seconds as in original
          dateLastPasswordChange: DateTime.now().subtract(
            const Duration(seconds: 5),
          ),
        );
        await userProfileRepo.writeUserProfile(updatedProfile);
        ref.invalidate(
          userProfileProvider,
        ); // Invalidate to refetch the updated profile
      }
    } on FirebaseAuthException catch (e) {
      String errorMessage;
      if (e.code == "wrong-password") {
        errorMessage = "Current password is incorrect.";
      } else if (e.code == "weak-password") {
        errorMessage = e.message ?? "Password is too weak.";
      } else if (e.code == "requires-recent-login") {
        errorMessage = "Please re-login to change your password.";
      } else {
        errorMessage = "An error occurred updating password. Please try again.";
      }
      throw Exception(errorMessage);
    } catch (e) {
      throw Exception("An unexpected error occurred updating password: $e");
    }
  }

  /// Updates the current user's email address.
  /// Note: Firebase `verifyBeforeUpdateEmail` sends a verification email.
  /// The email change is only finalized after the user clicks the link.
  /// Throws an [Exception] on failure.
  Future<void> updateEmail(String newEmail, {String? curPassword}) async {
    final userProfileRepo = ref.read(userProfileRepositoryProvider);
    final user = userProfileRepo
        .firebaseAuth
        .currentUser; // Use `firebaseAuth` from the repository
    if (user == null) {
      throw Exception("No authenticated user to update email.");
    }

    try {
      // Re-authenticate if an old password is provided
      if (curPassword != null) {
        final authCredential = EmailAuthProvider.credential(
          email: user.email!,
          password: curPassword,
        );
        await user.reauthenticateWithCredential(authCredential);
      }

      await user.verifyBeforeUpdateEmail(newEmail);
      // Inform the UI layer that a verification email has been sent.
      // The old email remains active until the new one is verified.
    } on FirebaseAuthException catch (e) {
      String errorMessage;
      if (e.code == "wrong-password") {
        errorMessage = "Current password is incorrect.";
      } else if (e.code == "invalid-email" ||
          (e.message?.contains("INVALID_NEW_EMAIL") ?? false)) {
        errorMessage = "$newEmail is not a valid email address.";
      } else if (e.code == "email-already-in-use") {
        errorMessage =
            e.message ?? "$newEmail is already in use by another user.";
      } else {
        errorMessage = "An error occurred updating email. Please try again.";
      }
      throw Exception(errorMessage);
    } catch (e) {
      throw Exception("An unexpected error occurred updating email: $e");
    }
  }

  /// Reauthenticates the current user with their password.
  /// Returns `true` if reauthentication is successful, `false` otherwise.
  Future<bool> reauthenticateUser(String password) async {
    final user = ref
        .read(userProfileRepositoryProvider)
        .firebaseAuth
        .currentUser; // Use `firebaseAuth` from the repository
    if (user == null) return false;

    try {
      final authCredential = EmailAuthProvider.credential(
        email: user.email!,
        password: password,
      );
      await user.reauthenticateWithCredential(authCredential);
      return true;
    } on FirebaseAuthException {
      return false; // Specific authentication error (e.g., wrong password)
    } catch (e) {
      // Handle other potential errors during reauthentication
      return false;
    }
  }

  // --- Helper Methods ---

  /// Validates a password string based on specified criteria.
  /// Returns an empty string if valid, otherwise an error message.
  String _validatePassword(String pwCandidate) {
    String passwordResponse = "Password must have: ";
    bool invalidPassword = false;
    int errorCount = 0;

    if (pwCandidate.isEmpty) {
      return 'Enter a password.';
    }

    if (pwCandidate.length < 6) {
      passwordResponse += "6 characters";
      invalidPassword = true;
      errorCount += 1;
    }

    if (!(RegExp(r"(?=.*[a-z])").hasMatch(pwCandidate) ||
        RegExp(r"(?=.*[A-Z])").hasMatch(pwCandidate))) {
      if (invalidPassword) {
        passwordResponse += ", letter";
      } else {
        passwordResponse += "letter";
        invalidPassword = true;
      }
      errorCount += 1;
    }

    if (!(RegExp(r"(?=.*\d)").hasMatch(pwCandidate))) {
      if (invalidPassword) {
        passwordResponse += ", digit";
      } else {
        passwordResponse += "digit";
        invalidPassword = true;
      }
      errorCount += 1;
    }

    if (!(RegExp(r"(?=.*\W)").hasMatch(pwCandidate))) {
      if (invalidPassword) {
        passwordResponse += ", symbol";
      } else {
        passwordResponse += "symbol";
        invalidPassword = true;
      }
      errorCount += 1;
    }

    if (invalidPassword) {
      passwordResponse += ".";
      if (passwordResponse.contains(", ")) {
        int lastIndex = passwordResponse.lastIndexOf(", ");
        String endingPhrase = (errorCount > 2) ? ", and" : " and";
        passwordResponse =
            passwordResponse.substring(0, lastIndex) +
            endingPhrase +
            passwordResponse.substring(lastIndex + 1);
      }
      return passwordResponse;
    }
    return "";
  }
}

// --- User Profile Stream Provider ---

/// Provides a stream of the current authenticated user's [UserProfile] object.
/// It watches the `authProvider` to react to user login/logout events.
@riverpod
Stream<UserProfile> userProfile(Ref ref) {
  final authUserAsync = ref.watch(
    authProvider,
  ); // Watch the authentication state

  // If there's no authenticated user, return an error stream
  // This will cause userProfileProvider.valueOrNull to be null in widgets,
  // indicating no profile is available.
  if (authUserAsync.valueOrNull == null) {
    return Stream.error(
      Exception("User not logged in or profile not available."),
    );
  }

  // Fetch the profile from the repository using the current user's UID.
  // Use `getUserProfileStream()` as per your repository's method name.
  return ref.watch(userProfileRepositoryProvider).getUserProfileStream();
}

// --- User Profile Image Stream Provider ---

/// Provides the profile image for the current authenticated user as a [Future<ImageProvider?>].
/// It depends on the `userProfileProvider` to get the user's UID.
@riverpod
Future<ImageProvider?> userProfileImage(Ref ref) async {
  final userProfileAsync = ref.watch(userProfileProvider);

  // If user profile is not loaded or there's an error, no image to fetch
  if (userProfileAsync.valueOrNull == null) {
    return null;
  }

  final user = userProfileAsync.value!; // Get the actual UserProfile object
  // Call `fetchUserProfileImage` on the repository, passing the UID.
  return ref
      .watch(userProfileRepositoryProvider)
      .fetchUserProfileImage(user.uid);
}

// --- User Profile Management Provider ---

/// Provides methods for performing actions related to the user profile,
/// such as writing data, uploading/removing images, and deleting account data.
/// It doesn't hold direct state but facilitates operations via the repository.
@riverpod
UserProfileManager userProfileManager(Ref ref) {
  return UserProfileManager(ref);
}

class UserProfileManager {
  final Ref _ref;

  UserProfileManager(this._ref);

  UserProfileRepository get _userProfileRepository =>
      _ref.read(userProfileRepositoryProvider);
  FirebaseAuth get _firebaseAuth => _ref
      .read(userProfileRepositoryProvider)
      .firebaseAuth; // Use `firebaseAuth`

  /// Writes the provided [UserProfile] to the database.
  /// After writing, it invalidates `userProfileProvider` to trigger a refetch.
  Future<void> writeUserProfile(
    UserProfile userProfile, {
    bool merge = true,
  }) async {
    await _userProfileRepository.writeUserProfile(userProfile, merge: merge);
    _ref.invalidate(
      userProfileProvider,
    ); // Force a refresh of the user profile stream
  }

  /// Uploads a new user profile image.
  /// Requires the current user to be authenticated.
  /// After upload, it invalidates `userProfileImageProvider` to show the new image.
  Future<void> uploadNewUserProfileImage(File imageFile) async {
    // Your repository method `uploadNewUserProfileImage` does not take UID as an argument,
    // it gets it internally.
    await _userProfileRepository.uploadNewUserProfileImage(imageFile);
    _ref.invalidate(
      userProfileImageProvider,
    ); // Force a refresh of the profile image
  }

  /// Removes the current user's profile image.
  /// Requires the current user to be authenticated.
  /// After removal, it invalidates `userProfileImageProvider` to clear the image.
  Future<void> removeUserProfileImage() async {
    // Your repository method `deleteUserProfileImage` does not take UID as an argument,
    // it gets it internally.
    await _userProfileRepository.deleteUserProfileImage();
    _ref.invalidate(
      userProfileImageProvider,
    ); // Force a refresh of the profile image (will become null)
  }

  /// Deletes all account data associated with the current user in Firestore and Storage.
  /// Note: This method does NOT delete the Firebase Auth user itself. That usually happens
  /// as a final step from the UI layer using `FirebaseAuth.instance.currentUser.delete()`.
  Future<void> deleteAccountData() async {
    // Your repository method `deleteUserProfileData` does not take UID as an argument,
    // it gets it internally.
    await _userProfileRepository.deleteUserProfileData();
    // Invalidate the profile provider as the data is now gone.
    _ref.invalidate(userProfileProvider);
    _ref.invalidate(userProfileImageProvider);
  }

  /// Checks if the user's password has been changed on another device since this one was authenticated.
  /// If so, it triggers a sign-out. This is typically called on app startup or before sensitive operations.
  Future<void> ensurePasswordUpToDate() async {
    final user =
        _firebaseAuth.currentUser; // Use `firebaseAuth` from the repository
    if (user == null) return; // Not authenticated, nothing to check

    final userProfileAsync = _ref.read(userProfileProvider);
    final userProfile =
        userProfileAsync.valueOrNull; // Handle loading/error states for profile

    if (userProfile == null) return; // Profile not loaded yet

    try {
      IdTokenResult idTokenResult = await user.getIdTokenResult();
      DateTime? lastAuthTime = idTokenResult.authTime;
      DateTime? lastPwChangeTime = userProfile.dateLastPasswordChange;

      if (lastAuthTime == null || lastPwChangeTime == null) return;

      if (lastPwChangeTime.isAfter(lastAuthTime)) {
        // Password was changed elsewhere; sign out this device.
        await _ref.read(authProvider.notifier).signOut();
        // The UI should react to the signOut and navigate to login.
      }
    } catch (e) {
      // Log any errors during this check, but don't prevent app from running
      // AppLogger.error("Error checking password update status: $e"); // If you want to use AppLogger here
    }
  }
}
