// Dart imports
import 'dart:async';
import 'dart:io';

// Flutter external package imports
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart'; // Required for ImageProvider
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

// App relative file imports
import '../models/user_profile.dart'; // Required for UserProfile
import '../repositories/user_profile_repository.dart'; // Make sure this path is correct
import 'user_profile_provider.dart'; // Import the new user profile provider

// These 'part' files will be generated by build_runner
part 'auth_provider.g.dart';

// AuthState enum, as provided in the refactored text example
enum AuthState { unknown, authenticated, unauthenticated }

@riverpod
class Auth extends _$Auth {
  @override
  Stream<User?> build() {
    // This stream directly reflects Firebase Auth state changes.
    // Riverpod automatically handles the subscription and exposes the state as AsyncValue<User?>.
    // We now use `firebaseAuth` as per your repository's internal FirebaseAuth instance.
    return ref
        .watch(userProfileRepositoryProvider)
        .firebaseAuth
        .authStateChanges();
  }

  // --- Authentication Actions ---

  /// Attempts to sign in the user with the given email and password.
  /// Throws an [Exception] with a user-friendly message on failure.
  Future<void> signInWithPassword(String email, String password) async {
    try {
      // Use `firebaseAuth` from the repository instance.
      await ref
          .read(userProfileRepositoryProvider)
          .firebaseAuth
          .signInWithEmailAndPassword(email: email, password: password)
          .timeout(
            const Duration(seconds: 10),
          ); // Added timeout from original logic
    } on FirebaseAuthException catch (e) {
      String errorMessage;
      if (e.code == "wrong-password" ||
          e.code == "user-not-found" ||
          e.code == "invalid-email" ||
          e.code == "INVALID_LOGIN_CREDENTIALS" ||
          e.code == "invalid-credential") {
        errorMessage =
            "Email/Password is incorrect - please check your credentials and try again.";
      } else if (e.code == "too-many-requests") {
        errorMessage =
            "Too many failed login attempts - please try again later.";
      } else if (e.code == "timeout") {
        errorMessage =
            "Login attempt took too long - please check internet connection and try again.";
      } else if (e.code == "network-request-failed") {
        errorMessage =
            "A network error occurred - please check internet connection and try again.";
      } else {
        errorMessage =
            "An unknown error occurred during authentication. Please try again.";
      }
      throw Exception(
        errorMessage,
      ); // Re-throw as a generic Exception for UI consumption
    } on TimeoutException {
      throw Exception(
        "Login attempt took too long - please check internet connection and try again.",
      );
    } catch (e) {
      throw Exception("An unexpected error occurred during sign-in: $e");
    }
  }

  /// Signs out the current user.
  /// Also clears Firebase Firestore persistence for a clean state.
  Future<void> signOut() async {
    // Use `firebaseAuth` from the repository instance.
    await ref.read(userProfileRepositoryProvider).firebaseAuth.signOut();
    // Clear Firebase Firestore persistence for a clean logout state.
    // This is a global operation, hence directly calling FirebaseFirestore.
    await FirebaseFirestore.instance.terminate();
    await FirebaseFirestore.instance.clearPersistence();
    // Riverpod will automatically dispose and rebuild dependent providers (like userProfileProvider)
    // when the Auth state changes to unauthenticated.
  }

  /// Updates the current user's password.
  /// Throws an [Exception] on failure.
  Future<void> updatePassword(String newPassword, {String? curPassword}) async {
    final userProfileRepo = ref.read(userProfileRepositoryProvider);
    final user = userProfileRepo
        .firebaseAuth
        .currentUser; // Use `firebaseAuth` from the repository
    if (user == null) {
      throw Exception("No authenticated user to update password.");
    }

    // Perform basic password validation locally
    String validationError = _validatePassword(newPassword);
    if (validationError.isNotEmpty) {
      throw Exception(validationError);
    }

    try {
      // Re-authenticate if an old password is provided (Firebase requires this for security)
      if (curPassword != null) {
        final authCredential = EmailAuthProvider.credential(
          email: user.email!,
          password: curPassword,
        );
        await user.reauthenticateWithCredential(authCredential);
      }

      await user.updatePassword(newPassword);

      // If password update is successful, update the `dateLastPasswordChange` in the UserProfile.
      // We read the current profile, create a copy with the updated date, and write it back.
      // This logic is now handled by UserProfileManager
      await ref
          .read(userProfileManagerProvider)
          .writeUserProfile(
            (await ref.read(userProfileProvider.future))!.copyWith(
              dateLastPasswordChange: DateTime.now().subtract(
                const Duration(seconds: 5),
              ),
            ),
          );
    } on FirebaseAuthException catch (e) {
      String errorMessage;
      if (e.code == "wrong-password") {
        errorMessage = "Current password is incorrect.";
      } else if (e.code == "weak-password") {
        errorMessage = e.message ?? "Password is too weak.";
      } else if (e.code == "requires-recent-login") {
        errorMessage = "Please re-login to change your password.";
      } else {
        errorMessage = "An error occurred updating password. Please try again.";
      }
      throw Exception(errorMessage);
    } catch (e) {
      throw Exception("An unexpected error occurred updating password: $e");
    }
  }

  /// Updates the current user's email address.
  /// Note: Firebase `verifyBeforeUpdateEmail` sends a verification email.
  /// The email change is only finalized after the user clicks the link.
  /// Throws an [Exception] on failure.
  Future<void> updateEmail(String newEmail, {String? curPassword}) async {
    final userProfileRepo = ref.read(userProfileRepositoryProvider);
    final user = userProfileRepo
        .firebaseAuth
        .currentUser; // Use `firebaseAuth` from the repository
    if (user == null) {
      throw Exception("No authenticated user to update email.");
    }

    try {
      // Re-authenticate if an old password is provided
      if (curPassword != null) {
        final authCredential = EmailAuthProvider.credential(
          email: user.email!,
          password: curPassword,
        );
        await user.reauthenticateWithCredential(authCredential);
      }

      await user.verifyBeforeUpdateEmail(newEmail);
      // Inform the UI layer that a verification email has been sent.
      // The old email remains active until the new one is verified.
    } on FirebaseAuthException catch (e) {
      String errorMessage;
      if (e.code == "wrong-password") {
        errorMessage = "Current password is incorrect.";
      } else if (e.code == "invalid-email" ||
          (e.message?.contains("INVALID_NEW_EMAIL") ?? false)) {
        errorMessage = "$newEmail is not a valid email address.";
      } else if (e.code == "email-already-in-use") {
        errorMessage =
            e.message ?? "$newEmail is already in use by another user.";
      } else {
        errorMessage = "An error occurred updating email. Please try again.";
      }
      throw Exception(errorMessage);
    } catch (e) {
      throw Exception("An unexpected error occurred updating email: $e");
    }
  }

  /// Reauthenticates the current user with their password.
  /// Returns `true` if reauthentication is successful, `false` otherwise.
  Future<bool> reauthenticateUser(String password) async {
    final user = ref
        .read(userProfileRepositoryProvider)
        .firebaseAuth
        .currentUser; // Use `firebaseAuth` from the repository
    if (user == null) return false;

    try {
      final authCredential = EmailAuthProvider.credential(
        email: user.email!,
        password: password,
      );
      await user.reauthenticateWithCredential(authCredential);
      return true;
    } on FirebaseAuthException {
      return false; // Specific authentication error (e.g., wrong password)
    } catch (e) {
      // Handle other potential errors during reauthentication
      return false;
    }
  }

  // --- Helper Methods ---

  /// Validates a password string based on specified criteria.
  /// Returns an empty string if valid, otherwise an error message.
  String _validatePassword(String pwCandidate) {
    String passwordResponse = "Password must have: ";
    bool invalidPassword = false;
    int errorCount = 0;

    if (pwCandidate.isEmpty) {
      return 'Enter a password.';
    }

    if (pwCandidate.length < 6) {
      passwordResponse += "6 characters";
      invalidPassword = true;
      errorCount += 1;
    }

    if (!(RegExp(r"(?=.*[a-z])").hasMatch(pwCandidate) ||
        RegExp(r"(?=.*[A-Z])").hasMatch(pwCandidate))) {
      if (invalidPassword) {
        passwordResponse += ", letter";
      } else {
        passwordResponse += "letter";
        invalidPassword = true;
      }
      errorCount += 1;
    }

    if (!(RegExp(r"(?=.*\d)").hasMatch(pwCandidate))) {
      if (invalidPassword) {
        passwordResponse += ", digit";
      } else {
        passwordResponse += "digit";
        invalidPassword = true;
      }
      errorCount += 1;
    }

    if (!(RegExp(r"(?=.*\W)").hasMatch(pwCandidate))) {
      if (invalidPassword) {
        passwordResponse += ", symbol";
      } else {
        passwordResponse += "symbol";
        invalidPassword = true;
      }
      errorCount += 1;
    }

    if (invalidPassword) {
      passwordResponse += ".";
      if (passwordResponse.contains(", ")) {
        int lastIndex = passwordResponse.lastIndexOf(", ");
        String endingPhrase = (errorCount > 2) ? ", and" : " and";
        passwordResponse =
            passwordResponse.substring(0, lastIndex) +
            endingPhrase +
            passwordResponse.substring(lastIndex + 1);
      }
      return passwordResponse;
    }
    return "";
  }

  /// Sends a verification email to the current user.
  /// Throws an exception if the user is not logged in or if Firebase fails.
  Future<void> resendVerificationEmail() async {
    final user = state.value; // Get user from the current state
    if (user == null) {
      throw Exception('No user is currently signed in.');
    }
    await user.sendEmailVerification();
  }

  Future<void> signUpWithPassword(String email, String password) async {
    try {
      // 1. Create the user in Firebase Auth
      final userCredential = await ref
          .read(userProfileRepositoryProvider)
          .firebaseAuth
          .createUserWithEmailAndPassword(email: email, password: password);

      // 2. Send verification email (if enforced)
      const bool ENFORCE_EMAIL_VERIFICATION = true;
      if (ENFORCE_EMAIL_VERIFICATION) {
        await userCredential.user?.sendEmailVerification();
      }
    } on FirebaseAuthException catch (e) {
      String message;
      if (e.code == 'weak-password') {
        message = 'The password provided is too weak.';
      } else if (e.code == 'email-already-in-use') {
        message = 'An account already exists for that email.';
      } else if (e.code == 'invalid-email') {
        message = 'The email address is not valid.';
      } else {
        message = 'An error occurred. Please try again.';
      }
      throw Exception(message);
    } catch (e) {
      throw Exception("An unexpected error occurred during sign-up.");
    }
  }

  /// Sends a password reset link to the given email address.
  Future<void> sendPasswordResetEmail(String email) async {
    try {
      await ref
          .read(userProfileRepositoryProvider)
          .firebaseAuth
          .sendPasswordResetEmail(email: email);
    } on FirebaseAuthException catch (e) {
      if (e.code == 'user-not-found') {
        // We don't want to reveal if an email exists or not for security.
        // So we don't throw an error here. The UI will show a generic success message.
        return;
      }
      throw Exception("An error occurred. Please try again.");
    }
  }
}
